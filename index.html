<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sleep Sound — Mic‑Gated + Your MP3</title>
  <style>
    :root { --bg:#0b1020; --fg:#e7ecf7; --muted:#98a3bd; --accent:#58a6ff; --ok:#31d0aa; --warn:#ffcc66; --bad:#ff6b6b; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    header{padding:20px 24px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    h1{font-size:20px;margin:0} .tag{padding:4px 8px;border:1px solid rgba(255,255,255,.15);border-radius:999px;font-size:12px;color:var(--muted)}
    main{padding:20px;max-width:1180px;margin:0 auto;display:grid;grid-template-columns:1.15fr .85fr;gap:20px}
    @media (max-width:1120px){main{grid-template-columns:1fr}}
    section.card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px;backdrop-filter:blur(6px)}
    h2{margin:0 0 12px;font-size:16px;color:var(--fg)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    button{appearance:none;background:linear-gradient(180deg,#2b65ff,#1f4fe0);border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,.25);color:var(--fg)}
    button.ghost{background:transparent;border:none;color:var(--muted);text-decoration:underline;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    input[type=range], input[type=text]{width:100%}
    .meter{height:12px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden}
    .bar{height:100%;background:linear-gradient(90deg,#31d0aa,#58a6ff);width:0%}
    .pill{font-size:12px;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12)}
    .warn{color:var(--warn)} .bad{color:var(--bad)} .ok{color:var(--ok)} .muted{color:var(--muted)}
    .log{font-family:ui-monospace,SFMono-Regular,Consolas,monospace;font-size:12px;height:240px;overflow:auto;background:rgba(0,0,0,.25);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.08)}
    .kv{display:grid;grid-template-columns:1fr auto;gap:6px;align-items:center}
    .kv div{display:flex;align-items:center;gap:8px}
    .kv label{color:var(--muted);font-size:12px}
    .hint{color:var(--muted);font-size:12px;line-height:1.5}
    .small{font-size:12px;color:var(--muted)}
    .banner{background:rgba(255,204,102,.08);border:1px solid rgba(255,204,102,.35);color:#ffd37a;padding:10px 12px;border-radius:10px}
    .error{background:rgba(255,107,107,.12);border:1px solid rgba(255,107,107,.45);color:#ff9b9b;padding:10px 12px;border-radius:10px}
    .tests{font-family:ui-monospace,SFMono-Regular,Consolas,monospace;font-size:12px;background:rgba(255,255,255,.06);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.08)}
    .section-title{display:flex;align-items:center;justify-content:space-between}
    canvas{width:100%;height:180px;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.08);border-radius:8px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .drop{border:1px dashed rgba(255,255,255,.35);padding:10px;border-radius:10px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <h1>Sleep Sound — Mic‑Gated + Your MP3</h1>
    <span class="tag">silent until noisy → then play your track; stop when quiet</span>
    <span class="tag" id="secureTag">Context: …</span>
    <span class="tag" id="permTag">Mic: unknown</span>
  </header>
  <main>
    <section class="card" id="live">
      <div class="section-title"><h2>Live Monitor</h2><span class="small">v4.3</span></div>
      <div class="banner" id="troubleshoot" style="display:none"></div>
      <div class="row" style="gap:8px">
        <button id="startBtn" type="button">Start (Mic)</button>
        <button id="stopBtn" class="secondary" type="button" disabled>Stop</button>
        <button id="selfTestBtn" class="ghost" type="button">Run Self‑Tests</button>
        <span class="pill" id="ctxState">Audio: idle</span>
        <span class="pill" id="maskState">Mask: off</span>
      </div>

      <div style="margin:14px 0">
        <div class="kv">
          <div><label>Input level</label><span id="levelDb">— dBFS</span></div>
          <div class="meter"><div class="bar" id="levelBar"></div></div>
        </div>
        <div class="kv" style="margin-top:10px">
          <div><label>Trigger threshold (≈ 35 dB SPL after calibration)</label><span id="thLabel"></span></div>
          <input id="threshold" type="range" min="-90" max="-20" step="1" value="-58" />
        </div>
      </div>

      <div class="grid">
        <div>
          <h3 class="small">Masking Source: Your uploaded MP3</h3>
          <div class="drop" id="drop">Drag & drop your MP3 here, or</div>
          <div class="row" style="margin-top:6px;gap:8px">
            <input id="fileInput" type="file" accept="audio/*" />
            <button id="useUploadedBtn" class="secondary">Pick your MP3</button>
            <span id="fileName" class="small"></span>
          </div>
          <p class="hint">Select <i>10 min white noise for stress - Tha Secret (youtube).mp3</i>. Browsers can’t read server paths; choosing the file gives the app a safe blob URL.</p>
          <label class="small" style="margin-top:8px">Masking Volume (calibrate ≈ 25 dB SPL)</label>
          <input id="maskGain" type="range" min="0" max="1" step="0.01" value="0.12" />
        </div>
        <div>
          <h3 class="small">Behavior</h3>
          <div class="row" style="gap:10px">
            <label class="small"><input id="ignoreSnore" type="checkbox" checked> Ignore snoring (low‑band dominant)</label>
            <label class="small"><input id="continuousMask" type="checkbox" checked> Keep playing while noisy</label>
          </div>
          <label class="small" style="margin-top:8px">Release after quiet (ms)</label>
          <input id="releaseMs" type="range" min="200" max="4000" step="100" value="800" />
          <p class="hint">Start is silent. When the mic detects disturbance ≥ threshold, your MP3 fades in; once quiet for the release time, it fades out <b>and pauses</b> (so it won’t keep running silently).</p>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="section-title"><h2>Events & Sleep Graph</h2><span class="small">(logs + simple chart)</span></div>
      <canvas id="chart" width="800" height="180"></canvas>
      <div class="log" id="log"></div>

      <h3 class="small" style="margin-top:12px">Self‑Tests</h3>
      <pre class="tests" id="testsOutput">(no tests run yet)</pre>
    </section>
  </main>

<script>
(() => {
  // ---------- Utilities & State ----------
  const $ = (id) => document.getElementById(id);
  const logEl = $('log');
  const testsOutput = $('testsOutput');
  const chartEl = $('chart');
  const log = (msg) => { const ts = new Date().toLocaleTimeString(); logEl.innerText = `[${ts}] ${msg}\n` + logEl.innerText; };

  // Audio graph (single global analyser — no redeclare)
  let audioCtx, analyser, micStream, micSource, rafId;
  let maskGainNode = null; // master gain for mask
  let maskMediaEl = null;  // <audio> element for your MP3
  let maskMediaSrcNode = null; // MediaElementSource

  // Flags/state
  let isMasking = false; let lastMode = 'idle';

  // UI elements
  const startBtn = $('startBtn');
  const stopBtn = $('stopBtn');
  const selfTestBtn = $('selfTestBtn');
  const ctxState = $('ctxState');
  const maskState = $('maskState');
  const secureTag = $('secureTag');
  const permTag = $('permTag');
  const troubleshoot = $('troubleshoot');

  const fileInput = $('fileInput');
  const useUploadedBtn = $('useUploadedBtn');
  const fileName = $('fileName');
  const drop = $('drop');

  const levelDb = $('levelDb');
  const levelBar = $('levelBar');
  const threshold = $('threshold'); const thLabel = $('thLabel');
  const maskGain = $('maskGain'); const releaseMs = $('releaseMs');
  const ignoreSnore = $('ignoreSnore');
  const continuousMask = $('continuousMask');

  // Chart buffers (last ~90s)
  const MAX_POINTS = 900; // 10 Hz * 90 s
  const seriesDb = []; const seriesMask = []; const seriesSnore = []; const seriesLoud = [];

  // Test hook
  window.__sleepSound = {
    simulatePermissionDenied: () => handleGetUserMediaError({name:'NotAllowedError'}),
    mode: () => lastMode,
    triggerMask: () => triggerMask(),
    classifyFrame: (arr) => classifySpectrum(arr, audioCtx ? audioCtx.sampleRate : 48000)
  };

  // ---------- Environment checks ----------
  function updateSecureTag(){
    const secure = window.isSecureContext;
    secureTag.textContent = `Context: ${secure ? 'HTTPS / secure' : 'Not secure'}`;
    secureTag.className = 'tag ' + (secure ? 'ok' : 'warn');
    if (!secure) showTroubleshooter('This page is not in a secure context. Microphone may be blocked. Use HTTPS.');
  }
  async function updatePermissionTag(){
    try{
      if (!navigator.permissions){ permTag.textContent = 'Mic: unknown'; return; }
      const st = await navigator.permissions.query({name:'microphone'});
      permTag.textContent = `Mic: ${st.state}`;
      permTag.className = 'tag ' + (st.state === 'granted' ? 'ok' : (st.state === 'prompt' ? 'warn' : 'bad'));
      st.onchange = () => { permTag.textContent = `Mic: ${st.state}`; };
    }catch{ permTag.textContent = 'Mic: unknown'; }
  }
  function showTroubleshooter(message){
    troubleshoot.style.display = 'block';
    troubleshoot.className = 'banner';
    troubleshoot.innerHTML = `<strong>Mic Troubleshooter:</strong> ${message} · Steps: Click address‑bar lock → Site settings → Allow Microphone → Reload.`;
  }

  // ---------- Audio helpers ----------
  function ensureAudioContext(){
    if (!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    if (audioCtx.state === 'suspended'){ audioCtx.resume(); }
    ctxState.textContent = `Audio: ${audioCtx.state} @ ${audioCtx.sampleRate} Hz`;
  }

  function connectMaskMediaFromFile(file){
    if (!audioCtx) ensureAudioContext();
    if (!maskGainNode){ maskGainNode = audioCtx.createGain(); maskGainNode.gain.value = 0.0; maskGainNode.connect(audioCtx.destination); }
    if (maskMediaEl){ try{ maskMediaEl.pause(); }catch{} }
    if (maskMediaSrcNode){ try{ maskMediaSrcNode.disconnect(); }catch{} }
    maskMediaEl = new Audio(); maskMediaEl.loop = true; maskMediaEl.crossOrigin = 'anonymous';
    maskMediaEl.src = URL.createObjectURL(file);
    maskMediaSrcNode = audioCtx.createMediaElementSource(maskMediaEl);
    maskMediaSrcNode.connect(maskGainNode);
  }

  function rampGain(param, target, ms){
    const now = audioCtx.currentTime; const t = Math.max(0, ms)/1000;
    param.cancelScheduledValues(now);
    param.setValueAtTime(param.value, now);
    param.linearRampToValueAtTime(target, now + t);
  }
  function computeRMS(buf){ let s=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; s += v*v; } return Math.sqrt(s/Math.max(1,buf.length)); }
  function dbFromRms(rms){ return 20 * Math.log10(Math.max(1e-8, rms)); }

  // Simple spectral classifier to ignore snoring
  const freqArr = new Uint8Array(1024);
  function classifySpectrum(freqArr, sampleRate){
    const fftSize = analyser ? analyser.fftSize : 2048;
    const binHz = sampleRate / fftSize;
    let low=0, mid=0, high=0;
    for(let i=0;i<freqArr.length;i++){
      const f = i * binHz; const v = freqArr[i];
      if (f >= 60 && f < 300) low += v; else if (f >= 300 && f < 3000) mid += v; else if (f >= 3000) high += v;
    }
    const lowRatio = low / Math.max(1, low+mid+high);
    const centroid = (low*180 + mid*1000 + high*6000) / Math.max(1, low+mid+high);
    const isSnore = (lowRatio > 0.58 && centroid < 700);
    return { isSnore };
  }

  function triggerMask(){
    if (!maskGainNode || !maskMediaEl){ log('Mask not ready — select your MP3 first.'); return; }
    if (isMasking) return;
    isMasking = true; maskState.textContent = 'Mask: on';
    const g = parseFloat(maskGain.value);
    rampGain(maskGainNode.gain, g, 150);
    // Start (or resume) playback only when masking actually begins
    maskMediaEl.play().catch(()=>{});
  }
  function stopMask(){
    if (!maskGainNode) return;
    rampGain(maskGainNode.gain, 0.0, 150);
    // NEW: also pause so the file doesn’t keep running silently, and reset to the start
    if (maskMediaEl && !maskMediaEl.paused){
      try { maskMediaEl.pause(); maskMediaEl.currentTime = 0; } catch {}
    }
    isMasking = false; maskState.textContent = 'Mask: off';
  }

  // ---------- Mic path ----------
  function handleGetUserMediaError(err){
    console.error(err);
    const msg = (err && err.name === 'NotAllowedError') ? 'Permission denied.' : (err && err.name ? err.name : 'Could not access microphone.');
    showTroubleshooter(`${msg} Use HTTPS and grant mic permission, then click Start again.`);
    startBtn.disabled = false; stopBtn.disabled = true; lastMode = 'idle';
    ctxState.textContent = 'Audio: mic blocked';
    permTag.textContent = 'Mic: blocked'; permTag.className = 'tag bad';
    log(`${msg} — awaiting user permission retry.`);
  }

  async function startMic(){
    try{
      ensureAudioContext();
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ throw {name:'NotSupportedError', message:'getUserMedia not supported'}; }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } });
      micStream = stream; micSource = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.85; micSource.connect(analyser);
      // Reflect granted permission in UI
      permTag.textContent = 'Mic: granted'; permTag.className = 'tag ok';
      startBtn.disabled = true; stopBtn.disabled = false; lastMode = 'mic';
      log('Mic granted. Monitoring (silent until threshold)…');
      loopMic();
    } catch(err){ handleGetUserMediaError(err); }
  }

  function stopAll(){
    cancelAnimationFrame(rafId);
    if (micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    if (audioCtx){ try{ audioCtx.close(); }catch{} audioCtx=null; }
    analyser = null; micSource=null; isMasking=false;
    startBtn.disabled = false; stopBtn.disabled = true; lastMode = 'idle';
    ctxState.textContent = 'Audio: idle'; maskState.textContent = 'Mask: off';
    log('Stopped.');
  }

  // ---------- Loops ----------
  let lastOverTs = 0;
  function loopMic(){
    const buf = new Float32Array(analyser.fftSize);
    const tick = () => {
      analyser.getFloatTimeDomainData(buf);
      const rms = computeRMS(buf); const db = dbFromRms(rms);
      levelDb.textContent = `${db.toFixed(1)} dBFS`;
      levelBar.style.width = Math.min(100, Math.max(0, (db + 90) / 70 * 100)) + '%';

      analyser.getByteFrequencyData(freqArr);
      const { isSnore } = classifySpectrum(freqArr, audioCtx.sampleRate);

      const over = db > parseFloat(threshold.value);
      const disturbance = over && (!ignoreSnore.checked || !isSnore);
      const now = performance.now();

      if (disturbance){
        lastOverTs = now;
        triggerMask();
      } else if (continuousMask.checked && isMasking) {
        const quietFor = now - lastOverTs;
        if (quietFor > parseInt(releaseMs.value,10)){
          stopMask();
          log('Mask off (quiet)');
        }
      }

      pushSeries(db, isSnore?1:0, disturbance?1:0, (isMasking?1:0));
      drawChart();
      rafId = requestAnimationFrame(tick);
    };
    tick();
  }

  // ---------- Chart helpers ----------
  function pushSeries(db, snore, loud, mask){
    seriesDb.push(db); seriesSnore.push(snore); seriesLoud.push(loud); seriesMask.push(mask);
    if (seriesDb.length > MAX_POINTS){ seriesDb.shift(); seriesSnore.shift(); seriesLoud.shift(); seriesMask.shift(); }
  }
  function drawChart(){
    const ctx = chartEl.getContext('2d'); const W = chartEl.width, H = chartEl.height; ctx.clearRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(255,255,255,.15)'; ctx.lineWidth = 1; ctx.beginPath(); for(let i=0;i<=4;i++){ const y = (H-10) * i/4 + 5; ctx.moveTo(0,y); ctx.lineTo(W,y);} ctx.stroke();
    const n = seriesDb.length; const step = W / Math.max(1, n);
    ctx.beginPath(); ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 1.5;
    for(let i=0;i<n;i++){ const x=i*step; const db=seriesDb[i]; const y = H - ((db + 90)/70)*H; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke();
    ctx.fillStyle = 'rgba(49,208,170,.25)'; for(let i=0;i<n;i++){ if(seriesMask[i]){ const x=i*step; ctx.fillRect(x,0,step,H);} }
    ctx.fillStyle = 'rgba(255,107,107,.6)'; for(let i=0;i<n;i++){ if(seriesLoud[i]){ const x=i*step; ctx.fillRect(x,H-6,step,6);} }
    ctx.fillStyle = 'rgba(255,204,102,.6)'; for(let i=0;i<n;i++){ if(seriesSnore[i]){ const x=i*step; ctx.fillRect(x,0,step,5);} }
  }

  // ---------- UI bindings ----------
  function updateThLabel(){ thLabel.textContent = `${threshold.value} dBFS`; }
  updateThLabel(); threshold.addEventListener('input', updateThLabel);

  // Ensure buttons are always enabled to click (even after prior errors)
  try { startBtn.disabled = false; stopBtn.disabled = true; } catch {}
  // Also make sure clicks are bound regardless of prior failures
  startBtn.addEventListener('click', () => { try { startMic(); } catch (e) { console.error(e); handleGetUserMediaError(e); }}, { once:false });
  stopBtn.addEventListener('click', () => { try { stopAll(); } catch (e) { console.error(e); }}, { once:false });
  selfTestBtn.addEventListener('click', () => { try { selfTestBtn.onclick && selfTestBtn.onclick(); } catch (e) { console.error(e); }}, { once:false });

  useUploadedBtn.onclick = () => fileInput.click();
  fileInput.onchange = () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) return;
    fileName.textContent = f.name;
    connectMaskMediaFromFile(f);
    log(`Loaded MP3: ${f.name}`);
  };

  // Drag & drop
  ;['dragenter','dragover'].forEach(evt => drop.addEventListener(evt, e=>{e.preventDefault(); drop.style.borderColor = '#58a6ff';}));
  ;['dragleave','drop'].forEach((evtName) => drop.addEventListener(evtName, (e)=>{ e.preventDefault(); drop.style.borderColor = 'rgba(255,255,255,.35)'; }));
  drop.addEventListener('drop', (e)=>{
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (f){ fileInput.files = e.dataTransfer.files; fileName.textContent = f.name; connectMaskMediaFromFile(f); log(`Loaded MP3: ${f.name}`);} 
  });

  startBtn.onclick = startMic; stopBtn.onclick = stopAll;
  maskGain.oninput = () => { if (!audioCtx || !maskGainNode) return; maskGainNode.gain.value = Math.min(maskGainNode.gain.value, parseFloat(maskGain.value)); };

  // ---------- Self tests (originals kept, plus a pause/reset check) ----------
  selfTestBtn.onclick = async () => {
    const results = []; const assert = (name, cond) => results.push(`${cond ? '✅' : '❌'} ${name}`);
    // math
    assert('RMS([0,0,0]) == 0', computeRMS(new Float32Array([0,0,0])) === 0);
    const rms1 = computeRMS(new Float32Array([1,-1])); assert('RMS([1,-1]) ≈ 1', Math.abs(rms1 - 1) < 1e-6);
    assert('dBFS(1) == 0', Math.abs(dbFromRms(1) - 0) < 1e-6);
    // envelope + silent start
    ensureAudioContext(); if (!maskGainNode){ maskGainNode = audioCtx.createGain(); maskGainNode.gain.value = 0.0; maskGainNode.connect(audioCtx.destination); }
    assert('silent at start (gain==0)', Math.abs(maskGainNode.gain.value - 0.0) < 1e-6);
    rampGain(maskGainNode.gain, 0.2, 0); assert('rampGain immediate set', Math.abs(maskGainNode.gain.value - 0.2) < 1e-3);
    // classifier basic (mock analyser so classifySpectrum has fftSize)
    analyser = { fftSize: 2048 };
    const fake = new Uint8Array(1024); for(let i=5;i<40;i++){ fake[i]=200; } for(let i=40;i<200;i++){ fake[i]+=5; }
    const cls = classifySpectrum(fake, 48000); assert('classifier flags low‑band as snore‑like', cls.isSnore === true);
    // behavior: trigger without MP3 must not engage masking
    const wasMask = isMasking; triggerMask(); assert('trigger without MP3 → still silent', isMasking === wasMask);
    // NEW: stopMask should pause + reset when a media element exists
    maskMediaEl = new Audio(); maskMediaEl.src = '';
    try { await maskMediaEl.play(); } catch {} // may be blocked; that's fine for the test
    isMasking = true; stopMask();
    assert('stopMask → paused', maskMediaEl.paused === true);
    assert('stopMask → reset to 0', Math.abs(maskMediaEl.currentTime) < 1e-3);

    // environment
    assert('Secure context flag is boolean', typeof window.isSecureContext === 'boolean');
    assert('Permissions API presence (soft)', typeof navigator.permissions !== 'undefined');
    testsOutput.textContent = results.join('\n'); log('Self‑tests executed.');
  };

  // Initial env indicators
  updateSecureTag(); updatePermissionTag();
})();
</script>
</body>
</html>
